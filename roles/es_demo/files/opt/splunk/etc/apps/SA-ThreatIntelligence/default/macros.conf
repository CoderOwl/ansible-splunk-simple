
#####################
## Filtering
#####################
[filter]
args =
definition = NOT tag=filtered
errormsg =
iseval = 0
validation =


#####################
## Incident Review
#####################
[incident_review]
args =
definition = inputlookup append=T incident_review_lookup | rename user as reviewer | `get_realname(owner)` | `get_realname(reviewer)` | eval nullstatus=if(isnull(status),"true","false") | `get_reviewstatuses` | eval status=if((isnull(status) OR isnull(status_label)) AND nullstatus=="false",0,status) | eval status_label=if(isnull(status_label) AND nullstatus=="false","Unassigned",status_label) | eval status_description=if(isnull(status_description) AND nullstatus=="false","unknown",status_description) | `mktime(time,_time,"%m/%d/%Y %H:%M:%S %Z")` | fields - nullstatus
errormsg =
iseval = 0
validation =

[incident_review_analyst_capacity]
definition = 12

[incident_review_capacity]
definition = `notable_owners` | search owner!="unassigned" | stats count as analyst_count | eval incident_review_capacity=analyst_count*`incident_review_analyst_capacity`

## Security Domains
[security_domains]
args = 
definition = inputlookup append=T security_domain_lookup | rename label as security_domain_label
errormsg =
iseval = 0
validation =


#####################
## Notable Events
#####################

###### Correlation Searches ######
[get_correlations]
args =
definition = lookup update=true correlationsearches_lookup savedsearch as source OUTPUTNEW security_domain, severity, rule_name, description as savedsearch_description, rule_title, rule_description, drilldown_name, drilldown_search, default_status, default_owner | eval security_domain=if(isnull(security_domain),"threat",lower(security_domain)) | eval governance_lookup_type="default" | lookup update=true governance_lookup savedsearch as source, lookup_type as governance_lookup_type OUTPUT governance, control | eval governance_lookup_type="tag" | lookup update=true governance_lookup savedsearch as source, tag, lookup_type as governance_lookup_type OUTPUT governance as governance_tag, control as control_tag | `mvappend_field(governance,governance_tag)` | `mvappend_field(control,control_tag)` | fields - governance_lookup_type,governance_tag,control_tag
errormsg =
iseval = 0
validation =

###### Governance ######
[governance]
args =
definition = inputlookup append=T governance_lookup | stats count by governance | fields - count
errormsg =
iseval = 0
validation =

[get_control(1)]
args = value
definition = control="$value$"
errormsg =
iseval = 0
validation =

[get_governance(1)]
args = value
definition = (tag="$value$" OR governance="$value$")
errormsg =
iseval = 0
validation =

[get_governance(2)]
args = governance, control
definition = `get_governance($governance$)` `get_control($control$)`
errormsg =
iseval = 0
validation =

###### Notables ######

## rename_if_tgt_null
##
## 1. Rename a field <src> to <prefix><separator><src> IFF the target field 
##    does not already exist.
## 2. Remove the field <src>
##
## If the source field does not exist this is a no-op (both fields will be null).
## Used in map_notable_fields macro to rename some fields IFF they do not exist.
## In some Correlation Searches, fields may already exist as part of "stats"
## command output; thus we use this macro to prevent the "stats" output from being
## overwritten.
##
[rename_if_tgt_null(3)]
args = field, prefix, sep
definition = eval $prefix$$sep$$field$ = if(isnull($prefix$$sep$$field$), $field$, $prefix$$sep$$field$) | fields - $field$
errormsg = 
iseval = 0
validation =


## Performs field renaming prior to events being written to notable index.
## Renaming is performed to retain information about the original event,
## as well as to satisfy certain requirements of the Notable Event renderer.
##
## Note that in AddInfoProcessor.cpp, these fields are automatically mapped by the
## SummaryIndexProcessor class and thus need not be renamed:
##   index       -> orig_index
##   source      -> orig_source
##   sourcetype  -> orig_sourcetype
##   host        -> orig_host
##   search_name -> source (set in header of stash file)
##
[map_notable_fields]
args = 
definition = eval orig_time=_time | `rename_if_tgt_null(_raw, "orig", "")` | `rename_if_tgt_null(event_id, "orig", "_")` | `rename_if_tgt_null(tag, "orig", "_")` | rename splunk_server as orig_splunk_server, linecount as orig_linecount, eventtype as orig_eventtype, timestartpos as orig_timestartpos, timeendpos as orig_timeendpos, event_hash as orig_event_hash, rule_name as orig_rule_name, security_domain as orig_security_domain, rule_title as orig_rule_title, rule_description as orig_rule_description, drilldown_search as orig_drilldown_search, drilldown_name as orig_drilldown_name, governance as orig_governance, control as orig_control, status as orig_status, owner as orig_owner, default_owner as orig_default_owner, tag::* as orig_tag::* | fields - date_*, punct
errormsg = 
iseval = 0
validation =

[notable]
args =
definition = `notable("*")`
errormsg =
iseval = 0
validation =

## notable(1) macro breakdown
## 1 -  Search notable index w/ option for a specific search
## 2 -  Explicit `filter` macro (to filter stuff out)
## 3 -  Remove host fields (they will always reflect local Splunk server name)
## 4 -  Get event_hash/event_id
## 5 -  Get rule_id and dedup
## 6 -  Get orig_tag
## 7 -  Get tag
## 8 -  Append orig_tag to tag
## 9 -  Dedup tag
## 10 - Get correlations
## 11 - Get review status
## 12 - Get owner
## 13 - Get urgency
## 14 - Get rule title
## 15 - Get rule description
## 16 - Fill some nulls
## 17 - Event typing
## 18 - Get tags (2nd/final round)
## 19 - Append orig_tag to tag
## 20 - Dedup tag
## 21 - Suppression extraction
[notable(1)]
args = search_name
definition = index=notable source="$search_name$" `filter` | fields - host_* | `get_event_id` | `dedup_rule_id` | `makemv(orig_tag)` | tags outputfield=tag | `mvappend_field(orig_tag,tag)` | `mvdedup(tag)` | `get_correlations` | `get_current_status` | `get_owner` | `get_urgency` | `get_rule_title` | `get_rule_description` | fillnull value=unknown rule_name,security_domain | typer | tags outputfield=tag | `mvappend_field(orig_tag,tag)` | `mvdedup(tag)` | `suppression_extract`
errormsg =
iseval = 0
validation =

###### Owner ######
[notable_owners]
args = 
definition = inputlookup append=T notable_owners_lookup | rename realname as owner_realname | eval owner_realname=if(isnull(owner_realname),owner,owner_realname) | sort + owner_realname
errormsg =
iseval = 0
validation =

## get_owner breakdown
## 1 - Determine status based on:
##     a.  Owner assignment in incident_review.csv
##     b.  Default owner provided via correlationsearches_lookup
## 2 - If owner is still null set to "unassigned"
## 3 - Lookup owner's realname
[get_owner]
args =
definition = eval owner=if(isnull(owner),default_owner,owner) | fillnull value=unassigned owner | `get_realname(owner)`
errormsg =
iseval = 0
validation =

###### Rule Description ######

## get_rule_description breakdown
## 1 - If rule_description does not exist; set as savedsearch_description
## 2 - If savedsearch description does not exist; set as unknown
[get_rule_description]
args =
definition = eval rule_description=if(isnull(rule_description),savedsearch_description,rule_description) | fillnull value=unknown rule_description
errormsg =
iseval = 0
validation =

###### Rule ID ######
[get_rule_id(1)]
args = fields
definition = eval rule_id=$fields$
errormsg =
iseval = 0
validation =

[dedup_rule_id]
args =
definition = eval rule_id=if(isnull(rule_id),event_id,rule_id) | fillnull value=unknown rule_id | dedup rule_id
errormsg =
iseval = 0
validation =

###### Rule Title ######

## get_rule_title breakdown
## 1 - If rule_title does not exist; set as rule_name
## 2 - If rule_name does not exist; set as source
[get_rule_title]
args =
definition = eval rule_title=if(isnull(rule_title),rule_name,rule_title) | eval rule_title=if(isnull(rule_title),source,rule_title)
errormsg =
iseval = 0
validation =

###### Statuses ######
[reviewstatuses]
args = 
definition = inputlookup append=T reviewstatuses_lookup | rename label as status_label | rename description as status_description | sort + status_label
errormsg =
iseval = 0
validation =

[get_reviewstatuses]
args =
definition = lookup update=true reviewstatuses_lookup status OUTPUT label as status_label,description as status_description,default as status_default,end as status_end | eval status=if(isnull(status) OR isnull(status_label),0,status) | fillnull value=Unassigned status_label | fillnull value=unknown status_description | `str_to_bool(status_default)` | `str_to_bool(status_end)` | eval status_group=case(status_default=="true","New",status_end=="true","Closed") | fillnull value="Open" status_group
errormsg =
iseval = 0
validation =

[reviewstatus_exclusions]
args =
definition = search NOT ((disabled=1 OR disabled=t OR disabled=true) AND (hidden=1 OR hidden=t OR hidden=true)) 
errormsg =
iseval = 0
validation =


## get_current_status breakdown
## 1 - Create temp_time from _time
## 2 - Set _time now+1d
## 3 - Perform temporal OUTPUT lookup for owner/new_urgency/status/reviewer
## 4 - Determine whether to take on a new_owner or not
## 5 - Determine whether to take on a new_status,default_status or not
## 6 - Determine whether to take on a new_urgency or not
## 7 - Set _time back
## 8 - Remove temp_time
## 9 - Determine status based on:
##     a. Status assignment in incident_review.csv
##     b. Default status provided via correlationsearches_lookup
## 10 - Final fillnull
[get_current_status]
args =
definition = eval temp_time=_time | eval _time=time()+86400 | lookup update=true incident_review_lookup rule_id OUTPUT time as review_time, owner as new_owner, urgency as new_urgency, status as new_status, comment as last_comment, user as reviewer | lookup update=true incident_review_comment_lookup rule_id OUTPUT comment | lookup update=true notable_owners_lookup owner as reviewer OUTPUTNEW realname as reviewer_realname | eval reviewer_realname=if(isnull(reviewer_realname),reviewer,reviewer_realname) | eval owner=if(isnotnull(new_owner),new_owner,owner) | eval status=case(isnotnull(new_status),new_status,isnull(status),default_status,isnotnull(status),status) | eval urgency=if(isnotnull(new_urgency),new_urgency,urgency) | eval _time=temp_time | fields - temp_time,new_owner,new_status,new_urgency | `get_reviewstatuses`
errormsg =
iseval = 0
validation =

[reviewstatus_groups]
definition = inputlookup append=T expected_status_group_lookup

[sort_reviewstatus_groups]
definition =  eval sortorder=case(status_group=="New",1,status_group=="Open",2,status_group=="Closed",3) | sort sortorder | fields - sortorder

###### Suppression ######
[suppression_extract]
args =
definition = eval sv_eventtype=mvjoin(eventtype, "|") | rex field=sv_eventtype "notable_suppression-(?<suppression>[^|]+)" | fields - sv_eventtype
errormsg =
iseval = 0
validation =

[get_suppression_start_time]
definition = rex field=search "_time>=?(?<start_time>\d+)"

[get_suppression_end_time]
definition = rex field=search "_time<=?(?<end_time>\d+)"

[suppression]
args =
definition = (eventtype=notable_suppression-* OR suppression=*)
errormsg =
iseval = 0
validation =

[suppression_audit]
args =
definition = eventtype=suppression_audit | fillnull value=unknown suppression, action, status, signature, user
errormsg =
iseval = 0
validation =

[suppression_audit-expired]
args =
definition = eventtype=suppression_audit-expired | fillnull value=unknown signature,suppression
errormsg =
iseval = 0
validation =

[suppression_eventtypes]
definition = rest /services/saved/eventtypes count=0 | search title=notable_suppression* | rename title as eventtype | `suppression_extract` | `get_suppression_start_time` | `get_suppression_end_time`

[suppressed_notables]
args = 
definition = `suppressed_notables("*")`
errormsg =
iseval = 0
validation =

[suppressed_notables(1)]
args = search_name
definition = `notable($search_name$)` | search `suppression`
errormsg =
iseval = 0
validation =


######################
## Risk
######################
[risk_object_types]
definition = inputlookup risk_object_types_lookup

[tla_default_risk_score]
definition = 40


######################
## Threat Intelligence
######################

[alexa_lookup]
definition = `alexa_lookup(src)` | `alexa_lookup(dest)`

[alexa_lookup(1)]
args = infield
definition = lookup local=true alexa_lookup_by_str domain AS $infield$ OUTPUTNEW rank AS $infield$_rank

[asn_lookup]
definition = `asn_lookup(src)` | `asn_lookup(dest)`

[asn_lookup(1)]
args = infield
definition = lookup local=true asn_lookup_by_str ip AS $infield$ OUTPUTNEW description AS $infield$_asn | lookup local=true asn_lookup_by_cidr ip AS $infield$ OUTPUTNEW description AS $infield$_asn

[bogonlist_lookup]
definition = `bogonlist_lookup(src)` | `bogonlist_lookup(dest)`

[bogonlist_lookup(1)]
args = infield
definition = lookup local=true bogonlist_lookup_by_cidr ip AS $infield$ OUTPUTNEW is_bogon AS $infield$_is_bogon,is_internal AS $infield$_is_internal

[threatlists]
definition = inputlookup threatlist_lookup_by_str | inputlookup append=t threatlist_lookup_by_cidr_static | dedup key | lookup local=true threatlist_lookup_by_str key AS key OUTPUT ip, category, name, description, risk, type | lookup local=true threatlist_lookup_by_cidr_static key AS key OUTPUTNEW ip, category, name, description, risk, type | mvexpand ip | dedup ip | eval subnet = if(match(ip, "/"), replace(ip, ".*\/", ""), 32) | eval ip_count=pow(2,32-subnet) | inputlookup append=t threatlist_lookup_by_domain_or_url | lookup threatlist_names name OUTPUT weight | table name category description risk type ip domain url subnet ip_count weight

[threatlist_lookup]
definition = `threatlist_lookup(src)` | `threatlist_lookup(dest)` | `threatlist_lookup_domain_or_url(url)`

[threatlist_lookup(1)]
args = infield
definition = lookup local=true threatlist_lookup_by_str key AS $infield$ OUTPUTNEW category AS $infield$_threatlist_category,description AS $infield$_threatlist_description,name AS $infield$_threatlist_name,risk AS $infield$_threatlist_risk,type AS $infield$_threatlist_type | lookup local=true threatlist_lookup_by_domain_or_url key AS $infield$ OUTPUTNEW category AS $infield$_threatlist_category,description AS $infield$_threatlist_description,name AS $infield$_threatlist_name,risk AS $infield$_threatlist_risk,type AS $infield$_threatlist_type | lookup local=true threatlist_lookup_by_cidr key AS $infield$ OUTPUTNEW category AS $infield$_threatlist_category_cidr,description AS $infield$_threatlist_description_cidr,name AS $infield$_threatlist_name_cidr,risk AS $infield$_threatlist_risk_cidr,type AS $infield$_threatlist_type_cidr | foreach $infield$_threatlist_* [eval <<FIELD>> = mvappend(<<FIELD>>, null, <<FIELD>>_cidr)] | fields - $infield$_threatlist_*_cidr

# String-based lookup for domains/URLs
[threatlist_lookup_domain_or_url(1)]
args = infield
definition = lookup local=true threatlist_lookup_by_domain_or_url key AS $infield$ OUTPUTNEW category AS $infield$_threatlist_category,description AS $infield$_threatlist_description,name AS $infield$_threatlist_name,risk AS $infield$_threatlist_risk,type AS $infield$_threatlist_type

[threatlist_categories]
# Categories are derived from threatlist content, if defined.
definition = inputlookup threatlist_categories | fields category | dedup category | rename category AS threatlist_category | sort 0 - threatlist_category

[threatlist_names]
# Threatlist names and weights are derived solely from the inputs.conf configuration stanzas.
definition = inputlookup threatlist_names | fields name, weight | dedup name, weight | rename name AS threatlist_name | sort 0 - threatlist_name

[threatlist_risk_score]
definition = `threatlist_risk_score(src)` | `threatlist_risk_score(dest)` | `threatlist_risk_score(url)`

## [threatlist_risk_score(1) breakdown
## 1 - Lookup up the threatlist in the threatlist_names lookup table to obtain
##     the weight. This results in a possibly multivalued field.
## 2 - Sum the weights for the multivalued field. This creates a monotonically
##     increasing field.
## 3 - Get the delta to retrieve the difference between each row and the next, 
##     which yields the sum for the current row.
## 4 - Run eval in case there is a null row (which is always the case for the
##     first row), to make sure the risk_score field is non-null.
## 5 - Remove extraneous fields.
[threatlist_risk_score(1)]
args = infield
definition = lookup threatlist_names name AS $infield$_threatlist_name OUTPUT weight AS $infield$_weight | streamstats sum($infield$_weight) as $infield$_sum_weight | delta $infield$_sum_weight AS $infield$_delta_weight | eval $infield$_risk_score=if(isnull($infield$_delta_weight),$infield$_sum_weight,$infield$_delta_weight) | fields - $infield$_sum_weight,$infield$_delta_weight

# Macros for combining lookups against both $field$ and $field$_domain.
[threatlist_lookup_extended]
definition = `truncate_domain_dedup(src)` | `truncate_domain_dedup(dest)` | `threatlist_lookup_include_domain` | `threatlist_risk_score_extended` | `threatlist_combine_info`

# CIDR lookups don't need to be conducted on URLs or domains. In the latter
# case, we should be guaranteed to get a hit from the src or dest lookup,
# since an IP address will be passed through the truncate_domain_dedup macro
# as-is based on the value of truncate_domain_allows_ips.
[threatlist_lookup_include_domain]
definition = `threatlist_lookup(src)` | `threatlist_lookup(dest)` | `threatlist_lookup_domain_or_url(src_domain)` | `threatlist_lookup_domain_or_url(dest_domain)` | `threatlist_lookup_domain_or_url(url)`

[threatlist_risk_score_extended]
definition = `threatlist_risk_score(src)` | `threatlist_risk_score(dest)` | `threatlist_risk_score(src_domain)` | `threatlist_risk_score(dest_domain)` | `threatlist_risk_score(url)`

[threatlist_combine_info]
definition = eval src_threatlist_name=mvappend(src_threatlist_name,null,src_domain_threatlist_name) | eval dest_threatlist_name=mvappend(dest_threatlist_name,null,dest_domain_threatlist_name) | eval src_threatlist_description=mvappend(src_threatlist_description,null,src_domain_threatlist_description) | eval dest_threatlist_description=mvappend(dest_threatlist_description,null,dest_domain_threatlist_description) | fillnull value=0 src_risk_score dest_risk_score src_domain_risk_score dest_domain_risk_score url_risk_score | eval src_risk_score=src_risk_score + src_domain_risk_score | eval dest_risk_score=dest_risk_score + dest_domain_risk_score

## truncate_domain(1) breakdown
## This macro truncates a domain to the length as defined in the Mozilla Public
## Suffix List (PSL), returning the registrable portion of the domain. The lookup table
## mozilla_publix_suffix_lookup must be defined for this to work, and the lookup
## table must be specially constructed. This emulates a wildcard lookup. 
## 1  - Split the domain field.
## 2  - Retrieve the right-most segment of the domain.
## 3  - Retrieve the two right-most segment of the domain.
## 4  - Retrieve the three right-most segments of the domain.
## 5  - Retrieve the four right-most segments of the domain.
## 6  - Run a string-based lookup on each segment of the domain and retrieve
##      the number of segments that constitute the registrable portion. Depending
##      on whether the rule in the PSL is a wildcard rule, normal rule, or
##      exception rule, the registrable segment length may exceed the length 
##      of the matched segment by 2, 1, or 0, respectively. Note: this uses 
##      the "foreach" command in a subsearch.
## 7a - Obtain the first matched length. Minimum is 2 (as you cannot register
##      single-word domain names). 
## 7b - Include or exclude any IP addresses that may inadvertently be included
##      in the list by checking that the last segment is non-numeric, based on
##      the value of the truncate_domain_allows_ips macro.
## 8  - Get the number of segments in the original domain.
## 9  - If the number of segments in the original domain is greater than or 
##      equal to the registrable length, assign it to $target$; otherwise return
##      null as this is not a valid domain name.
## 10 - Remove extraneous fields.
##
## Note: By default, IP addresses are passed through the macro unchanged. This
## permits the WHOIS data collection mechanisms to maintain records of IP addresses
## that are unresolvable but for which other domain intelligence might be 
## retrievable.
[truncate_domain(2)]
args = source,target
definition = eval $source$_src_segments=split(ltrim($source$, "."), ".") | eval seg1$source$=mvindex($source$_src_segments, -1) | eval seg2$source$ = mvjoin(mvindex($source$_src_segments, -2, -1), ".") | eval seg3$source$ = mvjoin(mvindex($source$_src_segments, -3, -1), ".") | eval seg4$source$ = mvjoin(mvindex($source$_src_segments, -4, -1), ".") | foreach seg*$source$ [lookup mozilla_public_suffix_lookup domain AS <<FIELD>> OUTPUTNEW length AS <<FIELD>>_length] | eval $target$_tgt_length = coalesce(seg4$source$_length,seg3$source$_length,seg2$source$_length,seg1$source$_length,if(isnum(seg1$source$),if(`truncate_domain_allows_ips`==0, null, 0), 2)) | eval $source$_src_length=mvcount($source$_src_segments) | eval $target$=if(isnull($target$_tgt_length), null, if($source$_src_length>=$target$_tgt_length, mvjoin(mvindex($source$_src_segments, -$target$_tgt_length, -1), "."), null)) | fields - seg*$source$ seg*$source$_length $source$_src_segments $source$_src_length $target$_tgt_length

[truncate_domain(1)]
args = source
definition = `truncate_domain($source$, $source$)`

## Change to anything except 0 to disallow IP addresses in truncate_domain
## output. 
[truncate_domain_allows_ips]
definition = 1

## truncate_domain_dedup(1) breakdown
## 1 - Run truncate_domain on the input field.
## 2 - If the result field name is identical to the source field name, or the
##     result value itself is identical to the source field value, set the 
##     truncated domain to null. This prevents lookups that might target the 
##     $source$_domain field from running twice
[truncate_domain_dedup(1)]
args = source
definition = `truncate_domain($source$, $source$_domain)` | eval $source$_domain=if("$source$_domain"="$source$" OR $source$_domain=$source$, null(), $source$_domain)

###### Urgency ######

## get_priority breakdown
## 1 - Create a MV priorities field out of known priority fields
## 2 - Convert MV priorities field into SV priorities field
## 3 - Convert prorities to lower
## 4 - Run priorities through prioritizer lookup to determine highest priority
## 5 - Remove priorities field
## 6 - Fillnull priority
[get_priority]
args =
definition = eval priorities=mvappend(priority, host_priority, orig_host_priority, src_priority, dest_priority, dvc_priority, src_user_priority, user_priority, host_owner_priority, orig_host_owner_priority, src_owner_priority, dest_owner_priority, dvc_owner_priority) | `makesv(priorities)` | `lower(priorities)` | lookup local=true prioritizer priorities OUTPUT priority | fields - priorities | fillnull value=unknown priority
errormsg =
iseval = 0
validation =

[urgency]
args =
definition = inputlookup append=T urgency_lookup
errormsg =
iseval = 0
validation =

## get_urgency breakdown
## 1 - Fillnull severity
## 2 - Convert severity to lower
## 2 - Get priority
## 3 - Perform urgency lookup based on OUTPUTNEW (will only override if urgency does not exist)
## 4 - Urgency should never be unknown based on lookup, but fillnull just in case
[get_urgency]
args =
definition = fillnull value=unknown severity | `lower(severity)` | `get_priority` | lookup local=true urgency_lookup priority,severity OUTPUTNEW urgency | fillnull value=unknown urgency
errormsg =
iseval = 0
validation =
