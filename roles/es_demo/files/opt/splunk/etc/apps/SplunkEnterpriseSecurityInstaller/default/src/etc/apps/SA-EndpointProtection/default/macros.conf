
#####################
## CPU
#####################
[cputime]
## Note: Some systems will report usage for multiple CPUs. In System Center
## values from multiple CPUs on a destination are averaged across all CPUs.
definition = (sourcetype="*:CPUTime" NOT sourcetype="Perfmon:CPUTime") OR (sourcetype="Perfmon:CPUTime" PercentProcessorTime=*) OR (sourcetype=cpu AND cpu="all") | tags outputfield=tag | fillnull value=unknown PercentProcessorTime | eval PercentProcessorTime=if(PercentProcessorTime="unknown",PercentSystemTime+PercentUserTime,PercentProcessorTime) | search NOT PercentProcessorTime=unknown

[cputime(1)]
args       = host
definition = dest=$host$ `cputime`

[cputime(2)]
args       = host, limit
definition = `cputime($host$)` | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## Disk
#####################
[disk]
definition = (sourcetype=*:FreeDiskSpace NOT sourcetype=Perfmon:FreeDiskSpace) OR sourcetype=df | append [search sourcetype=Perfmon:FreeDiskSpace | transaction _time, dest, collection, object, instance | search PercentFreeSpace=* FreeMBytes=*] | tags outputfield=tag | search NOT mount=*Total | fillnull value=0 FreeMBytes,PercentFreeSpace,TotalMBytes,UsedMBytes | eval PercentFreeSpace=if(PercentFreeSpace<=0,0.01,PercentFreeSpace) | eval PercentFreeSpaceDec=PercentFreeSpace/100 | eval TotalMBytes=if(sourcetype=="WMI:FreeDiskSpace" OR sourcetype="Perfmon:FreeDiskSpace",FreeMBytes/PercentFreeSpaceDec,TotalMBytes) | eval UsedMBytes = if(sourcetype=="WMI:FreeDiskSpace" OR sourcetype="Perfmon:FreeDiskSpace",TotalMBytes-FreeMBytes,UsedMBytes) | eval FreeMBytes=round(FreeMBytes) | eval TotalMBytes=round(TotalMBytes) | eval UsedMBytes=round(UsedMBytes)

[disk(1)]
args       = host
definition = dest=$host$ `disk`

[disk(2)]
args       = host, limit
definition = `disk($host$)` | transaction _time,dest | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## Endpoint Changes
#####################
[endpoint_change]
definition = tag=endpoint tag=change | tags outputfield=tag | fillnull value=unknown action,dest,object,object_category,object_path,status,user


######################
## Interesting lookups
######################
[get_interesting_ports]
definition = lookup interesting_ports_lookup transport,dest_port,dest OUTPUTNEW is_required,is_prohibited,is_secure,note | fillnull value="undefined" is_required,is_prohibited,is_secure | `lower(is_required)` | `lower(is_prohibited)` | `lower(is_secure)`

[get_interesting_processes]
definition = lookup interesting_processes_lookup app as process,dest OUTPUTNEW is_required,is_prohibited,is_secure,note | fillnull value="undefined" is_required,is_prohibited,is_secure | `lower(is_required)` | `lower(is_prohibited)` | `lower(is_secure)`

[get_interesting_services]
definition = lookup interesting_services_lookup app as service,dest OUTPUTNEW is_required,is_prohibited,is_secure,note | fillnull value="undefined" is_required,is_prohibited,is_secure | `lower(is_required)` | `lower(is_prohibited)` | `lower(is_secure)`


#####################
## Listening Ports
#####################
[listeningports]
definition = tag=listening tag=port | tags outputfield=tag | fillnull value=0 dest_port | fillnull value="unknown" dest,transport | eval transport=lower(transport) | `get_transport_dest_port`

[listeningports(1)]
args       = host
definition =  dest=$host$ `listeningports`

[listeningports(2)]
args       = host, limit
definition =  `listeningports($host$)` | transaction _time,dest | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0

[listeningports_tracker]
definition = inputlookup append=T listeningports_tracker | `get_asset(dest)` | `get_identity4events(dest_owner)`


#####################
## Malware
#####################
[malware]
definition = tag=malware tag=attack | tags outputfield=tag | fillnull value=unknown action,category,signature,dest,dest_nt_domain,user,file_name,file_path,file_hash | `get_vendor_product`

[malware_tracker]
definition = inputlookup append=T malware_tracker | `get_asset(dest)` | `get_identity4events(dest_owner)`

[malware_operations]
definition = tag=malware tag=operations | eval dest_nt_domain=if(isnull(dest_nt_domain),"unknown",dest_nt_domain) | eval vendor_product=case(isnotnull(vendor_product),vendor_product,isnotnull(vendor) AND vendor!="unknown" AND isnotnull(product) AND product!="unknown",vendor." ".product,isnotnull(vendor) AND vendor!="unknown" AND (isnull(product) OR product="unknown"),vendor." unknown",(isnull(vendor) OR vendor="unknown") AND isnotnull(product) AND product!="unknown","unknown ".product,isnotnull(sourcetype),sourcetype,1=1,"unknown")

[malware_operations_tracker]
definition = inputlookup append=T malware_operations_tracker | `get_asset(dest)` | `get_identity4events(dest_owner)`

## Legacy Malware Operations Macros
[malware_product_versions]
definition = tag=endpoint tag=application tag=version | dedup dest | tags outputfield=tag | `get_vendor_product` | fillnull value="unknown" product_version

[malware_signature_updates]
definition = tag=endpoint tag=application tag=signature tag=update | dedup dest | tags outputfield=tag | `get_vendor_product` | fillnull value="unknown" signature_version

## Product Deployment Tracker
[malware_product_deployment_tracker]
definition = `assets` | join type=outer asset_id [| `malware_operations_tracker` | eval lastTime=_time | rename dest_asset_id as asset_id | fields asset_id,lastTime] | eval _time=lastTime | `timeDiff` | `dayDiff`


#####################
## Memory
#####################
[memory]
definition = (sourcetype="*:Memory" OR sourcetype=vmstat) NOT sourcetype=Perfmon:Memory | append [search sourcetype=Perfmon:Memory | transaction _time, dest, collection, object | search FreeMBytes=* UsedBytes=*] | tags outputfield=tag | eval UsedMBytes=UsedBytes/1048576 | eval TotalMBytes=if(sourcetype=="WMI:Memory" OR sourcetype="Perfmon:Memory", FreeMBytes+UsedMBytes, TotalMBytes) | eval FreeMBytes=round(FreeMBytes) | eval UsedMBytes=round(UsedMBytes) | eval TotalMBytes=round(TotalMBytes)

[memory(1)]
args = host
definition = dest=$host$ `memory`

[memory(2)]
args       = host, limit
definition = `memory($host$)` | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## Persistence
#####################

## Select tags to be persisted
##
## NOTE: This macro selects the subset of tags that will be persisted.
##       Modify this macro to persist additional tags.
[settags_endpoint]
definition = ( tag="update" OR tag="should_update" )


#####################
## Primary functions
#####################
[primary_functions]
definition = inputlookup append=T primary_function_lookup

## This will continue to be driven by lookup files.  The tsidx implementation for this is a bit unnatural.
[primary_functions_tracker]
definition = inputlookup append=T localprocesses_tracker | `get_primary_function(process)` | rename app as process | inputlookup append=T services_tracker | search app=* StartMode="Auto" | `get_primary_function(service)` | rename app as service | inputlookup append=T listeningports_tracker | `get_primary_function-port` | `get_asset(dest)` | `get_identity4events(dest_owner)`

[get_primary_function(1)]
args       = type
definition = lookup primary_function_lookup $type$ as app OUTPUTNEW is_primary,function | `str_to_bool(is_primary)`
errormsg   = primary function (arg1) must be one of: service, process
iseval     = 0
validation = type=="process" OR type=="service"

[get_primary_function-port]
definition = lookup primary_function_lookup transport,port as dest_port OUTPUTNEW is_primary,function | `str_to_bool(is_primary)`


#####################
## Processes
#####################
[localprocesses]
definition = tag=process tag=report | tags outputfield=tag | fillnull value="unknown" dest,process | eval UsedMBytes=UsedBytes/1048576

[localprocesses(1)]
args       = host
definition = dest=$host$ `localprocesses`

[localprocesses(2)]
args       = host, limit
definition = `localprocesses($host$)` | transaction _time,dest | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0

[localprocesses_tracker]
definition = inputlookup append=T localprocesses_tracker | `get_asset(dest)` | `get_identity4events(dest_owner)`


#####################
## SELinux
#####################
[selinuxconfig]
definition = sourcetype="*:SELinuxConfig"

[selinuxconfig(1)]
args       = host
definition = dest=$host$ `selinuxconfig`

[selinuxconfig(2)]
args       = host, limit
definition = `selinuxconfig($host$)` | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## Services
#####################
[service]
definition = tag=service tag=report | tags outputfield=tag | fillnull value="unknown" dest,service,start_mode,status,State

[service(1)]
args       = host
definition = dest=$host$ `service`

[service(2)]
args       = host, limit
definition = `service($host$)` | transaction _time,dest | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0

[services_tracker]
definition = inputlookup append=T services_tracker | `get_asset(dest)` | `get_identity4events(dest_owner)`


#####################
## SSHD
#####################
[sshdconfig]
definition = sourcetype="*:SSHDConfig"

[sshdconfig(1)]
args       = host
definition = dest=$host$ `sshdconfig`

[sshdconfig(2)]
args       = host, limit
definition = `sshdconfig($host$)` | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## Time
#####################
[time_sync]
definition = tag=time tag=synchronize

[time_sync(1)]
args       = action
definition = tag=$action$ `time_sync`

[index_time_delta]
definition = `get_summary("endpoint_summary","Endpoint - Index Time Delta 2 - Summary Gen")` | rename orig_* as * | rename tag::orig_* as tag::*

[ntp_startmode]
definition = `ntp_startmode("*")`

[ntp_startmode(1)]
args       = host
definition = tag=time `service($host$)` | dedup dest


#####################
## Update
#####################
[system_update]
definition = tag=system tag=update tag=status | tags outputfield=tag | fillnull value=unknown signature_id,signature,status,dest

[system_update_tracker]
definition = tstats `summariesonly` max(_time) as _time,latest(Updates.status) as status,latest(Updates.dest_should_update) as dest_should_update from datamodel=Updates by Updates.dest,Updates.signature_id,Updates.vendor_product | `drop_dm_object_name("Updates")` | `get_update_signature` | sort - _time,dest,signature | fields _time,status,signature_id,signature,dest,dest_should_update	    

[update_startmode]
definition = `update_startmode("*")`

[update_startmode(1)]
args       = host
definition = tag=update `service($host$)` | `tag2field_should(update)` | dedup dest

[get_update_signature]
definition = lookup update=true update_signature_reference_lookup signature_id,vendor_product OUTPUTNEW signature


#####################
## Uptime
#####################
[uptime]
definition = tag="uptime" | dedup dest | tags outputfield=tag | `uptime2string(SystemUpTime,label)`

[uptime(1)]
args       = host
definition = dest=$host$ `uptime`

[uptime(2)]
args       = host, limit
definition = `uptime($host$)` | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0


#####################
## User Accounts
#####################
[useraccounts]
definition = sourcetype="*:UserAccounts" | tags outputfield=tag | rex field=password "\*(?<password>)"

[useraccounts(1)]
args       = host
definition = dest=$host$ `useraccounts`

[useraccounts(2)]
args       = host, limit
definition = `useraccounts($host$)` | transaction _time,dest | head $limit$
errormsg   = limit (arg2) must be greater than 0
iseval     = 0
validation = limit > 0

[useraccounts_tracker]
definition = inputlookup append=T useraccounts_tracker | `get_identity4events(user)` | `get_asset(dest)` | `get_identity4events(dest_owner)`


#####################
## Version
#####################
[system_version]
definition = tag=system tag=version | tags outputfield=tag | fillnull value=unknown os | eval os=if(os=="unknown",os_name." ".os_release,os) | `os_normalization` | dedup dest

[os_normalization]
definition = eval os=replace(os,"\(R\)","") | eval os=replace(os,"\\\\xA8","") | eval os=replace(os,"MS Windows","Microsoft Windows") | eval os=replace(os,"^Windows","Microsoft Windows")
